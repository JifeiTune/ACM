#include<iostream>
#include<algorithm>
#include<vector>
#include<cstring>
#include<cstdio>
#include<map>
#include<set>
#include<string>
#include<list>
#include<cmath>
#include<stack>
#include<ctime>

using namespace std;

/*
堆， 就是特殊的完全二叉树，任意父节点值必须大于等于或小于等于所有后代节点值
大于等于为大顶堆，小于等于为小顶堆，堆排序的过程就是不断维护堆结构的过程
怎么表示这棵树呢？初学时有一个误区是看见树就以为要用指针来表示
其实用一个数组来存储完全二叉树的层次遍历序列，假设编号从1开始
那么对于一个编号为n的节点2*n就是其左子树，2*n+1就是其右子树
n/2取整为其父节点，当然一切都要确保不越界
以大顶堆为例

首先明确这样一个事实：如果当前已经有一个大顶堆，现在其堆顶上因为出现了比堆顶小的元素
将堆顶元素换成了更小的元素，再从堆顶往下调整，一定能调整为正确的堆结构
因为既然原来是符合堆结构的，那么堆顶元素的左右子树也是符合堆结构的
现在堆顶元素变了，假设不符合堆结构了，即存在左右子节点比它大
那么选择左右子节点中，较大的那个，和堆顶交换，然后可以发现：
1、未交换的那个子节点，以之为堆顶的堆符合堆结构
2、现在的堆顶，大于等于所有左右子树的元素值，唯一可能出现问题的，是那个和原堆顶交换了的子节点，
以之为堆顶的堆结构
于是我们再以交换了的那个子节点出发，重复上述步骤，最终就调整好了堆结构
这个自堆顶向下调整的过程称为“筛选”

堆排序
1、先将原序列（看做数组表达的二叉树）转换成堆
因为筛选时要求左右子堆符合堆结构，所以应从低层节点开始筛选
叶节点显然是符合堆结构的，所以从编号最大的非叶子节点开始（编号为n/2，即最后一个节点的父节点）
往前不断进行筛选操作，最后就能调整好堆结构

2、输出堆顶元素，再调整堆结构
现在已经符合堆结构了，那么堆顶就是最大元素，将之输出，输出后，堆元素数目减一
输出后，堆顶元素空缺，但是左右子堆还是符合堆结构的，怎么办呢？
我们可以在不破坏左右子堆的堆结构的前提下，填补堆顶，再进行一次筛选
显然，取走一个叶子节点，填补在堆顶，是不会破坏左右子堆结构的，为了方便，每次就取最后一个节点
然后再进行筛选，调整堆结构
重复这个过程，直到堆元素个数为1
*/

int x[1000001];//从1开始编号
int n;//元素个数

void adjust(int root,int ed)//调整以root为堆顶，ed为尾的堆结构
{
    int i,a,b,p,L,R,num=ed/2;
    while(root<=num)//往下调，但堆顶编号不会超过最后一个非叶子节点
    {
        L=2*root,R=L+1;//左右子节点编号
        p=-1;
        if(x[L]>x[root]) p=L;//L必然不越界
        if(R<=ed&&x[R]>x[root]&&x[R]>x[L]) p=R;
        if(p!=-1)
        {
            swap(x[root],x[p]);
            root=p;//继续向下调整
        }
        else
        {
            break;//不必交换，满足堆结构
        }
    }
}

void heapSort()
{
    for(int i=n;i>1;i--)//不断将当前尾元素和堆顶交换，重新调整堆结构
    {
        swap(x[1],x[i]);
        adjust(1,i-1);
    }
}

int main()
{
    srand((unsigned)time(NULL));
    ios::sync_with_stdio(false);
    n=10000;
    int i;
    for(i=1;i<=n;i++)
    {
        x[i]=rand();
    }
    for(i=n/2;i>=1;i--)//从最后一个非叶子节点，向前筛选
    {
        adjust(i,n);
    }
    heapSort();
    for(i=1;i<=n;i++)
    {
        printf("%d\n",x[i]);
    }
    return 0;
}




